.data
str:    .asciiz "abcd"    # Input string to be shuffled.
depth:  .word 2              # Depth of shuffling.
newline: .asciiz "\n"

.text
.globl main

main:
    la $a0, str               # Load address of the string.
    lw $a1, depth             # Load the shuffle depth.
    li $a2, 0                 # Initial full string length indicator.
    jal shuffle               # Call the shuffle procedure.

    # Print the shuffled string.
    la $a0, str               # Address of the shuffled string for printing.
    li $v0, 4                 # Syscall to print string.
    syscall

    # Print a newline for cleanliness.
    la $a0, newline
    syscall

    # Exit program.
    li $v0, 10
    syscall

shuffle:
    beqz $a1, return          # Base case: If depth is 0, return.

    addiu $sp, $sp, -16        # Allocate space on the stack for $ra and previous half-length.
    sw $ra, 4($sp)            # Save $ra on the stack.
    sw $a2, 0($sp)            # Save the current half-length.
    sw $a1, 8($sp)            #Save depth
    
    # Check if $a2 is zero (indicating full string length needs to be calculated).
    beqz $a2, calculate_length
    j update_a2        # If $a2 is not zero, skip length calculation.

calculate_length:
    move $t0, $a0             # Copy the base address of the string.
    li $t1, 0                 # Initialize length counter.    


strlen_loop:
    lb $t2, 0($t0)            # Load byte from string.
    beqz $t2, update_a2       # If byte is zero, end of string.
    addiu $t1, $t1, 1         # Increment length counter.
    addiu $t0, $t0, 1         # Move to the next character.
    move $t3, $t1
    j strlen_loop

update_a2:
    move $a2, $t1             # Update $a2 with the full string length.
    j proceed_to_swap

proceed_to_swap:
    srl $t3, $t3, 1           # Calculate half-length for the current recursion level.
    sw $t3, 16($sp)         #Save t3.
    # Perform the swapping based on $t3, which now contains the correct half-length.
    # (Swapping logic remains the same as before.)

    addiu $a1, $a1, -1        # Decrement depth for recursion.
    li $t4, 0                 # Reset index for swapping.
swap_loop:
    beq $t4, $t3, after_swap  # Done swapping if index equals half-length.
    add $t5, $a0, $t4         # Address of char in first half.
    add $t6, $a0, $t3         # Start of the second half.
    add $t6, $t6, $t4         # Address of corresponding char in the second half.
    lb $t7, 0($t5)            # Load byte from first half.
    lb $t8, 0($t6)            # Load byte from second half.
    sb $t7, 0($t6)            # Swap bytes.
    sb $t8, 0($t5)
    addiu $t4, $t4, 1         # Increment swap index.
    j swap_loop

after_swap:
    # Recursive call for the first half. $a2 is already set to the correct half-length.
    jal shuffle

    # Prepare for the second half.
    move $a2, $t1            # Restore the full length for this level.
    lw $a1, 8($sp)          #Restore depth info.
    srl $a2, $a2, 1           # Halve the length again for the second half.
    lw $t3, 16($sp).    #Restore og t3.
    add $a0, $a0, $t3         # Adjust $a0 to point to the start of the second half.
    jal shuffle               # Recursive call for the second half.

    # Restore $ra and the previous half-length from the stack.
    lw $ra, 4($sp)
    lw $a2, 0($sp)            # Restore the previous half-length for debugzzz.
    addiu $sp, $sp, 16         # Deallocate space from the stack.

return:
    jr $ra                    # Return to the caller.
