.data
str:    .asciiz "Computer"    # Input string to be shuffled.
depth:  .word 3               # Depth of shuffling.
newline: .asciiz "\n"

.text
.globl main

main:
    la $a0, str               # Load address of the string.
    lw $a1, depth             # Load the shuffle depth.
    jal shuffle               # Call the shuffle procedure.

    # Print the shuffled string.
    la $a0, str               # Address of the shuffled string for printing.
    li $v0, 4                 # Syscall to print string.
    syscall

    # Print a newline for cleanliness.
    la $a0, newline
    syscall

    # Exit program.
    li $v0, 10
    syscall

shuffle:
    beqz $a1, return          # Base case: If depth is 0, return.

    # Save registers that will be used.
    addiu $sp, $sp, -12       # Allocate space on the stack for 3 words.
    sw $ra, 8($sp)            # Save return address.
    sw $a0, 4($sp)            # Save original $a0 (string address).
    sw $a1, 0($sp)            # Save original $a1 (depth).

    # Halve the string length for swapping.
    li $t0, 0                 # Counter for the loop.
    lw $t1, 0($sp)            # Load the depth.
    move $t2, $a0             # Copy of string address to calculate length.
    li $t3, 0                 # Length counter.

strlen_loop:
    lb $t4, 0($t2)            # Load byte from string.
    beqz $t4, strlen_done     # If byte is zero, we're at the end of the string.
    addiu $t2, $t2, 1         # Move to the next byte.
    addiu $t3, $t3, 1         # Increment length counter.
    j strlen_loop

strlen_done:
    sra $t5, $t3, 1           # $t5 = length / 2, calculate mid-point.

swap_halves:
    beq $t0, $t5, after_swap  # If done swapping, jump to after_swap.
    add $t6, $a0, $t0         # Address of current char in first half.
    add $t7, $a0, $t5         # Calculate start of the second half.
    add $t7, $t7, $t0         # Address of corresponding char in the second half.
    lb $t8, 0($t6)            # Load byte from first half.
    lb $t9, 0($t7)            # Load byte from second half.
    sb $t8, 0($t7)            # Swap the bytes.
    sb $t9, 0($t6)
    addiu $t0, $t0, 1         # Increment loop counter.
    j swap_halves

after_swap:
    # Restore depth for recursion.
    lw $a1, 0($sp)            # Restore original $a1 (depth).
    addiu $a1, $a1, -1        # Decrement depth for next level of recursion.

    # Recursive call for the first half.
    jal shuffle

    # Prepare for recursion on the second half.
    lw $a0, 4($sp)            # Restore original $a0.
    add $a0, $a0, $t5         # Adjust $a0 to the start of the second half.
    lw $a1, 0($sp)            # Restore original $a1 and decrement again for the second half.
    addiu $a1, $a1, -1        # Ensure the depth is correctly decremented for the second half as well.

    jal shuffle               # Recursive call for 2nd half 
    
        # Restore registers and adjust the stack pointer back.
    lw $ra, 8($sp)            # Restore the return address.
    addiu $sp, $sp, 12        # Deallocate space on the stack.

return:
    jr $ra                    # Return to the caller.


