.data
str:    .apace 1024    # Input string holder to be shuffled. (Max 1024/4 = 256 Length string allowed!)

askStr: .asciiz "Input: "
resultStr: .asciiz "Output: "

.text
.globl main

main:
    
    
    # Ask for input
    la $a0, askStr # print input request
    addi $v0, $zero, 4
    syscall
    # Get input
    
    # Get string
    la $a0 str
    addi $v0, $zero, 8
    addi $a1, $zero, 256 # Max length of a string
    syscall
    # Get integer
    
    addi $v0, $zero, 5 # Read int
    syscall
    add $a1, $zero, $v0 # Push the depth value to a1
  
    
    # Start the functiom 
    
    la $a0, str           # Load address of the string.
    li $a2, 0             # Initial full string length indicator.
    addiu $sp, $sp, -4   # Allocate space on the stack for $ra
    sw $ra, 4($sp)        # Save $ra on the stack.

    jal shuffle           # Call the shuffle procedure.

    # Clean up stack and print the shuffled string.
    lw $ra, 4($sp)        # Restore $ra
    addiu $sp, $sp, 4  # Deallocate space from the stack.
    
     # Print "output"
    la $a0, resultStr
    li $v0, 4
    syscall 
    
    la $a0, str           # Address of the shuffled string for printing.
    li $v0, 4             # Syscall to print string.
    syscall
    
  

    # Exit program.
    li $v0, 10
    syscall

shuffle:
    # a0 address of the string.
    # a1 the shuffle depth.
    # a2 Ianitial full string length indicator.
    

    beqz $a1, return      # Base case: If depth is 0, return.
    addiu $a1, $a1, -1    # Decrement depth for recursion.

    beqz $a2, calculate_length  # Calculate string length if $a2 is 0.

update_a2:
    srl $a2, $a2, 1       # Halve the string length for the current recursion.
    j proceed_to_swap

calculate_length:
    move $t0, $a0         # Copy the base address of the string.
    li $t1, 0             # Initialize length counter.

strlen_loop:
    lb $t2, 0($t0)        # Load byte from string.
    move $a2, $t1
    beqz $t2, update_a2   # If byte is zero, end of string.
    addiu $t1, $t1, 1     # Increment length counter.
    addiu $t0, $t0, 1     # Move to the next character.
    j strlen_loop

proceed_to_swap:
    # Perform the swapping based on the halved string length $a2.

    li $t4, 0             # Reset index for swapping.
swap_loop:
    beq $t4, $a2, after_swap  # Done swapping if index equals half-length.
    add $t5, $a0, $t4     # Address of char in first half.
    add $t6, $a0, $a2     # Calculate start of the second half.
    add $t6, $t6, $t4     # Address of corresponding char in the second half.
    lb $t7, 0($t5)        # Load byte from first half.
    lb $t8, 0($t6)        # Load byte from second half.
    sb $t7, 0($t6)        # Swap bytes.
    sb $t8, 0($t5)
    addiu $t4, $t4, 1     # Increment swap index.
    j swap_loop

after_swap:

    # Recursive call for the left half of the current string.
    # Saving variables
    sub $sp, $sp, 20
    sw $a0, 0($sp)       
    sw $a1, 4($sp)
    sw $a2, 8($sp)
    sw $s0, 12($sp)
    sw $ra, 16($sp)
    
    # Preserve the base address of the current section.
    # Preserve the halved length for the left half recursion.
    jal shuffle
    # Loading variables back
    
    lw $a0, 0($sp)        
    lw $a1, 4($sp)        
    lw $a2, 8($sp)        
    lw $s0, 12($sp)
    lw $ra, 16($sp)
    addi $sp, $sp, 20
    
    # Calculate length and prepare for the right half recursion.
    # Saving variables
    sub $sp, $sp, 20
    sw $a0, 0($sp)       
    sw $a1, 4($sp)        
    sw $a2, 8($sp)        
    sw $s0, 12($sp)
    sw $ra, 16($sp)
    add $a0, $a0, $a2         # Calculate the base address for the right half.
    jal shuffle # Recalculate length for the right half and shuffle.
    
    # Loading variables back 
    
    lw $a0, 0($sp)        
    lw $a1, 4($sp)
    lw $a2, 8($sp)   
    lw $s0, 16($sp)
    lw $ra, 16($sp)     
    addi $sp, $sp, 20
    
return:
    jr $ra                # Return to the caller.

    .end                    # End of the program.
